import{_ as r,M as t,p as h,q as d,R as o,t as e,N as i,a1 as a}from"./framework-a05dfeeb.js";const s={},l=a('<h1 id="scoring-theory" tabindex="-1"><a class="header-anchor" href="#scoring-theory" aria-hidden="true">#</a> Scoring Theory</h1><p>Once we have a list of matching items, they need to be ranked by a <strong>relevance score</strong>. This score is determined by three factors:</p><ul><li>Fuzziness score</li><li>Key weight</li><li>Field-length norm</li></ul><h3 id="fuzziness-score" tabindex="-1"><a class="header-anchor" href="#fuzziness-score" aria-hidden="true">#</a> Fuzziness Score</h3>',4),u={href:"https://en.wikipedia.org/wiki/Bitap_algorithm",target:"_blank",rel:"noopener noreferrer"},p=a('<h4 id="distance-threshold-and-location" tabindex="-1"><a class="header-anchor" href="#distance-threshold-and-location" aria-hidden="true">#</a> Distance, Threshold, and Location</h4><p>The calculation for something to be considered a match (whether fuzzy or exact) takes into account how far the pattern is from the expected location, within a threshold.</p><p>To illustrate, consider the following options:</p><ul><li><code>location</code> defaults to <code>0</code></li><li><code>distance</code> defaults to <code>100</code></li><li><code>threshold</code> defaults to <code>0.6</code></li></ul><p>With the above options, for something to be considered a match, it would have to be within (threshold) <code>0.6</code> x (distance) <code>100</code> = <code>60</code> characters away from the expected location <code>0</code>.</p><p>For example, consider the string <code>&quot;Fuse.js is a powerful, lightweight fuzzy-search library, with zero dependencies&quot;</code>. Searching for the pattern <code>&quot;zero&quot;</code> would not match anything, even though it occurs in the string. The reason is that with the above defaults, for it to be considered a match it would have to be within <code>60</code> characters away from the expected location <code>0</code>. However, <code>&quot;zero&quot;</code> appears at index <code>62</code>.</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>If you don&#39;t care where the pattern appears in the string, and you still want to consider it a match, set <code>ignoreLocation</code> to <code>true</code>.</p></div><h3 id="key-weight" tabindex="-1"><a class="header-anchor" href="#key-weight" aria-hidden="true">#</a> Key Weight</h3><p>User inputted weight of the key. The higher the weight, the higher its relevance score. This is optional, although Fuse.js will internally default it to <code>1</code> if one isn&#39;t provided. This boosting is applied at query time.</p><h3 id="field-length-norm" tabindex="-1"><a class="header-anchor" href="#field-length-norm" aria-hidden="true">#</a> Field-length Norm</h3><p>The shorter the field, the higher its relevance. If a pattern matches a short field (such as a <code>title</code> field) it is likely to be more relevant than the same pattern matched with a bigger field. This is calculated at index time.</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>You can ignore the field-length norm by setting <code>ignoreFieldNorm</code> to <code>true</code>. Alternatively, you can configure how much the field-length norm affects your scoring by setting <code>fieldNormWeight</code> to a value other than 1 (the default).</p></div>',12);function f(g,m){const n=t("ExternalLinkIcon"),c=t("Donate");return h(),d("div",null,[l,o("p",null,[e("The fuzziness score is internally calculated via a modified implementation of the "),o("a",u,[e("Bitap"),i(n)]),e(" algorithm.")]),p,i(c)])}const w=r(s,[["render",f],["__file","scoring-theory.html.vue"]]);export{w as default};
